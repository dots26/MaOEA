#' Compute the R2-mtch from Ishibuchi et al.
#' @title Modified tchebyscheff R2-indicator
#' @param dataPoints The Points coordinate. Each column contains a single point (column major).
#' @param reference The reference point for computing R2-mtch (similar as reference for HV)
#' @param weights The weights/direction to be used to compute the achievement scalarization. Each column contains a single weight vector. If no weight is supplied, weights are generated using Sobol sequences.
#' @param axisDivision Used only when no weights are supplied. An input for the structured weight distribution. This defines how many division are created in each axis.
#'
#' @return The function return the R2-indicator of the set.
#' @examples
#' nPointToSample <- 100
#' nObjective <- 3
#' points <- matrix(runif(nPointToSample*nObjective), nrow = nObjective) # sample the points
#' ranks <- nsga2R::fastNonDominatedSorting(t(points)) # non-dominated sorting
#' points <- points[,ranks[[1]],drop=FALSE] # take only the non-dominated front
#' nPoints <- ncol(points) # check how many points are on the non-dominated front
#' reference <- rep(2,nObjective)
#'
#' compute_R2mtch(points,reference)
#' @export
compute_R2mtch <- function(dataPoints,reference,weights=NULL,nPoints = 100){
  nObj <- nrow(dataPoints)
  if(is.null(weights)) {
    weights <- createWeightsSobol(nDim=nObj,nWeights = nPoints)
  }
  #  if(is.null(weights)) {
  #    weights <- createWeights(nObj,axisDivision,noZero = TRUE)
  #  }
  sumR2 <- 0

  nWeight <- ncol(weights)
  nPoints <- ncol(dataPoints)
  for(weightIndex in 1:nWeight){
    pointAchievementVector <- NULL
    for(pointIndex in 1:nPoints){
      pointAchievementVector <- append(pointAchievementVector,
                                       gmtch(dataPoints[,pointIndex],reference,weights[,weightIndex])
      )
    }
    sumR2 <- sumR2+(max(pointAchievementVector))
  }
  return(sumR2/nWeight)
}

#' Compute the R2-HV from Ishibuchi et al.
#' @title Modified powered tchebyscheff R2-indicator designed to approximate HV
#' @param dataPoints The Points coordinate. Each column contains a single point (column major).
#' @param reference The reference point for computing R2-mtch (similar as reference for HV)
#' @param weights The weights/direction to be used to compute the achievement scalarization. Each column contains a single weight vector. If no weight is supplied, weights are generated using Sobol sequences.
#' @param nPoints Used only when no weights are supplied. An input for the weight generator (sobol sequences). This defines how many points are created.
#'
#' @return The function return the powered R2-indicator of the set.
#' @examples
#' nPointToSample <- 100
#' nObjective <- 3
#' points <- matrix(runif(nPointToSample*nObjective), nrow = nObjective) # sample the points
#' ranks <- nsga2R::fastNonDominatedSorting(t(points)) # non-dominated sorting
#' points <- points[,ranks[[1]],drop=FALSE] # take only the non-dominated front
#' nPoints <- ncol(points) # check how many points are on the non-dominated front
#' reference <- rep(2,nObjective)
#'
#' compute_R2HV(points,reference)
#' @export
compute_R2HV <- function(dataPoints,reference,weights=NULL,nPoints = 100){
  nObj <- nrow(dataPoints)
  if(is.null(weights)) {
    weights <- createWeightsSobol(nDim=nObj,nWeights = nPoints)
  }
  #if(is.null(weights)) {
  #  weights <- createWeights(nObj,axisDivision,noZero = TRUE)
  #}
  sumR2 <- 0

  nWeight <- ncol(weights)
  nPoints <- ncol(dataPoints)
  for(weightIndex in 1:nWeight){
    pointAchievementBest <- -Inf
    for(pointIndex in 1:nPoints){
      this.gmtch <- gmtch(dataPoints[,pointIndex],reference,weights[,weightIndex])^nObj
      if(pointAchievementBest< this.gmtch)
        pointAchievementBest <- this.gmtch
    }
    sumR2 <- sumR2+pointAchievementBest
  }
  return(sumR2/nWeight)
}

#' Compute the R2-HV contribution from Ishibuchi et al.
#' @title Modified tchebyscheff R2-indicator contribution designed to approximate HV
#' @param dataPoints The Points coordinate. Each column contains a single point (column major).
#' @param reference The reference point for computing R2-mtch (similar as reference for HV)
#' @param weights The weights/direction to be used to compute the achievement scalarization. Each column contains a single weight vector. If no weight is supplied, weights are generated using Sobol sequences
#' @param nWeights Used only when no weights are supplied. The number of weights generated by sobol sequence.
#'
#' @return The function return R2-indicator contribution of each point.
#' @examples
#' nPointToSample <- 100
#' nObjective <- 3
#' points <- matrix(runif(nPointToSample*nObjective), nrow = nObjective) # sample the points
#' ranks <- nsga2R::fastNonDominatedSorting(t(points)) # non-dominated sorting
#' points <- points[,ranks[[1]],drop=FALSE] # take only the non-dominated front
#' nPoints <- ncol(points) # check how many points are on the non-dominated front
#' reference <- rep(2,nObjective)
#'
#' compute_R2HVC(points,reference)
#' @export
compute_R2HVC <- function(dataPoints,reference,weights=NULL,alpha=1,nWeight = 300,indexOfInterest = 1:ncol(dataPoints)){
  nObj <- nrow(dataPoints)
  if(is.null(weights)) {
    weights <- createWeightsSobol(nDim=nObj,nWeights = nWeight)
  }
  sumR2 <- 0
  R2contrib <- NULL
  R2skewness <- NULL
  R2median <- NULL
  R2sd <- NULL
  R2kurtosis <- NULL

  nWeight <- ncol(weights)
  nPoints <- ncol(dataPoints)
  for(sIndex in indexOfInterest){
    sumR2 <- 0
    minRset <- NULL
    for(weightIndex in 1:nWeight){
      minimumStar <- Inf
      pointAchievementToBoundary <- gmtch(reference,dataPoints[,sIndex],weights[,weightIndex])

      for(secondaryPointIndex in 1:nPoints){
        if( secondaryPointIndex != sIndex){
          new_g2tch <- g2tch_star(dataPoints[,secondaryPointIndex],dataPoints[,sIndex],weights[,weightIndex])

          if(minimumStar > new_g2tch ){
            #print(secondaryPointIndex)
            minimumStar <- new_g2tch
          }
        }
      }
      #print(c('windex',weightIndex))
     # print(c(weightIndex,minimumStar,pointAchievementToBoundary))
      minR <- min(c(minimumStar,pointAchievementToBoundary))
      # print(c(weightIndex,minR,minR^alpha))
      minR <- minR^alpha
      #      sumR2 <- sumR2 + minR
      minRset <- append(minRset,minR)
    }
    R2contrib <- append(R2contrib,mean(minRset))
    R2sd <- append(R2sd,sd(minRset))
    R2skewness <- append(R2skewness,e1071::skewness(minRset,1))
    R2kurtosis <- append(R2kurtosis,e1071::kurtosis(minRset,1))
    R2median <- append(R2median,median(minRset))
  }
  return(list(maxval=max(minRset),R2=R2contrib,sd=R2sd,skew=R2skewness,kurtosis=R2kurtosis,median=R2median))
}

gmtch <- function(point, reference, weight){
  nObj <- nrow(point)
  achievement_vector <- abs(point-reference)/weight

  if(min(achievement_vector) <0)
  print('gmtch')
#  print(min(achievement_vector))
  return(min(achievement_vector))
}


g2tch <- function(point, ref, weight){
  nObj <- nrow(point)
  achievement_vector <- abs(point-ref)/weight
  return(max(achievement_vector))
}

g2tch_star <- function(a, s, weight){
  nObj <- nrow(a)
  achievement_vector <- (a-s)/weight


  return(max(achievement_vector))
}

#' Generate a set of weights following Das and Dennis's method. Each column returned is a weight vector.
#' @title Das and Dennis's structured weight generation (NBI)
#' @param nDim The dimensionality of the problem. In EA, usually this is used in the objective space, hence nDim = nObjective
#' @param axisDivision Used only when no weights are supplied. An input for the structured weight distribution. This defines how many division are created in each axis.
#' @param noZero Default to false. If set to TRUE, reference vector containing zero, e.g. (1,0,0) will be removed. Used to generate weight in modified tch method.

#' @return The function return a set of weight vectors.
#' @examples
#' nObjective <- 3
#' axisDiv <- 6
#'
#' createWeights(nObjective,axisDiv)
#' @export
createWeights <- function(nDim,axisDivision = nDim+2,noZero=FALSE){
  #REFERENCE POINT DEFINITION
  nRefPoint <- choose(nObjective+axisDivision-1,axisDivision)

  referencePoint <- matrix(,nrow = nObjective,ncol = nRefPoint)
  referenceCombination <- gtools::combinations(nObjective,axisDivision,1:nObjective,repeats.allowed = TRUE)
  for(objectiveIndex in 1:nObjective){
    this.objective <- as.integer(referenceCombination==objectiveIndex)
    this.objective <- matrix(this.objective,nrow = nRefPoint,ncol = axisDivision)
    for(referencePointIndex in 1:nRefPoint)
      referencePoint[objectiveIndex,referencePointIndex] <- sum(this.objective[referencePointIndex,])
  }

  if(noZero){
    if(axisDivision <= nDim){
      stop('Number of axis division must be larger than problem dimension, otherwise no internal point will be created.')
    }
    removeCol <- NULL
    for(refIndex in 1:nRefPoint){
      if(min(referencePoint[,refIndex])==0){
        removeCol <- append(removeCol,refIndex)
      }
    }
    referencePoint <- referencePoint[,-removeCol]
  }

  nRefPoint <- ncol(referencePoint)
  for(refIndex in 1:nRefPoint){
    referencePoint[,refIndex] <- referencePoint[,refIndex]/norm(referencePoint[,refIndex,drop=FALSE],'F')
  }

  return(referencePoint)
}

#' Generate a set of weights following Sobol sequence generator
#' @title Sobol sequence weights
#' @param nWeights Number of weights to generate.
#' @param nDim The dimensionality of the problem. In EA, usually this is used in the objective space, hence nDim = nObjective
#' @param seed Seed for scrambling
#' @return The function return a set of weight vectors.
#' @examples
#' nObjective <- 3
#' nPoint <- 1000
#'
#' createWeightsSobol(nPoint,nObjective)
#' @export
createWeightsSobol <- function(nWeights, nDim,seed=4177){
  weights <- randtoolbox::sobol(nWeights, dim = nDim,scrambling=3,seed = seed)
  weights <- t(weights)
  for(pointIndex in 1:nWeights){
    weights[,pointIndex] <- weights[,pointIndex]/norm(weights[,pointIndex,drop=FALSE],'F')
  }

  return(weights)
}
